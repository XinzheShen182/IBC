{
  "EndEventFuncFrame": "func (cc *SmartContract) {event}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tinstance,err:=cc.GetInstance(ctx, instanceID)\n\tevent, err := cc.ReadEvent(ctx, instanceID, \"{event}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif event.EventState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Event state %s is not allowed\", event.EventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeEventState(ctx, instance, event.EventID, COMPLETED) \n\tstub.SetEvent(\"{event}\", []byte(\"EndEvent has been done\"))\n\t{after_all_hook}\n\tcc.SetInstance(ctx, instance)\n\treturn nil\n}}",
  "package": "package chaincode\n",
  "import": "import (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"reflect\"\n\t\"crypto/sha256\"\n\t\"strings\"\n\t\"encoding/hex\"\n\t\"github.com/hyperledger/fabric-chaincode-go/shim\"\n\t\"github.com/hyperledger/fabric-contract-api-go/contractapi\"\n)\n",
  "contract_definition": "type SmartContract struct {\n\tcontractapi.Contract\n}\n",
  "fix_part": "type ContractInstance struct {\n\t// Incremental ID\n\tInstanceID string `json:\"InstanceID\"`\n\t// global Memory\n\tInstanceStateMemory StateMemory `json:\"stateMemory\"`\n\t// map type from string to Message、Gateway、ActionEvent\n\tInstanceMessages      map[string]*Message      `json:\"InstanceMessages\"`\n\tInstanceGateways      map[string]*Gateway      `json:\"InstanceGateways\"`\n\tInstanceActionEvents  map[string]*ActionEvent  `json:\"InstanceActionEvents\"`\n\tInstanceBusinessRules map[string]*BusinessRule `json:\"InstanceBusinessRule\"`\n\tInstanceParticipants  map[string]*Participant  `json:\"InstanceParticipants\"`\n\t// state of the instance\n\tInstanceState InstanceState `json:\"InstanceState\"`\n}\n\ntype ElementState int\n\nconst (\n\tDISABLED = iota\n\tENABLED\n\tWAITINGFORCONFIRMATION // means wait continue in BusinessRule\n\tCOMPLETED\n)\n\ntype InstanceState int\n\ntype Participant struct {\n\tParticipantID string            `json:\"ParticipantID\"`\n\tMSP           string            `json:\"MSP\"`\n\tAttributes    map[string]string `json:\"Attributes\"`\n\tIsMulti       bool              `json:\"IsMulti\"`\n\tMultiMaximum  int               `json:\"MultiMaximum\"`\n\tMultiMinimum  int               `json:\"MultiMinimum\"`\n\n\tX509 string `json:\"X509\"`\n}\n\ntype Message struct {\n\tMessageID            string       `json:\"MessageID\"`\n\tSendParticipantID    string       `json:\"SendMspID\"`\n\tReceiveParticipantID string       `json:\"ReceiveMspID\"`\n\tFireflyTranID        string       `json:\"FireflyTranID\"`\n\tMsgState             ElementState `json:\"MsgState\"`\n\tFormat               string       `json:\"Format\"`\n}\n\ntype Gateway struct {\n\tGatewayID    string       `json:\"GatewayID\"`\n\tGatewayState ElementState `json:\"GatewayState\"`\n}\n\ntype ActionEvent struct {\n\tEventID    string       `json:\"EventID\"`\n\tEventState ElementState `json:\"EventState\"`\n}\n\ntype BusinessRule struct {\n\tBusinessRuleID string            `json:\"BusinessRuleID\"`\n\tCID            string            `json:\"Cid\"`\n\tHash           string            `json:\"Hash\"`\n\tDecisionID     string            `json:\"DecisionID\"`\n\tParamMapping   map[string]string `json:\"ParamMapping\"`\n\tState          ElementState      `json:\"State\"`\n}\n\nfunc (cc *SmartContract) CreateBusinessRule(ctx contractapi.TransactionContextInterface, instance *ContractInstance, BusinessRuleID string, DMNContent string, DecisionID string, ParamMapping map[string]string) (*BusinessRule, error) {\n\n\tHash, err := cc.hashXML(ctx, DMNContent)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\t// 创建业务规则对象\n\tinstance.InstanceBusinessRules[BusinessRuleID] = &BusinessRule{\n\t\tBusinessRuleID: BusinessRuleID,\n\t\tCID:            \"\",\n\t\tHash:           Hash,\n\t\tDecisionID:     DecisionID,\n\t\tParamMapping:   ParamMapping,\n\t\tState:          DISABLED,\n\t}\n\n\treturnBusinessRule, ok := instance.InstanceBusinessRules[BusinessRuleID]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为BusinessRule\")\n\t}\n\n\treturn returnBusinessRule, nil\n}\n\nfunc (cc *SmartContract) CreateParticipant(ctx contractapi.TransactionContextInterface, instance *ContractInstance, participantID string, msp string, attributes map[string]string, x509 string, IsMulti bool, MultiMaximum int, MultiMinimum int) (*Participant, error) {\n\n\t// 创建参与者对象\n\tinstance.InstanceParticipants[participantID] = &Participant{\n\t\tParticipantID: participantID,\n\t\tMSP:           msp,\n\t\tAttributes:    attributes,\n\t\tIsMulti:       IsMulti,\n\t\tMultiMaximum:  MultiMaximum,\n\t\tMultiMinimum:  MultiMinimum,\n\t\tX509:          x509,\n\t}\n\n\treturnParticipant, ok := instance.InstanceParticipants[participantID]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为Participant\")\n\t}\n\n\treturn returnParticipant, nil\n\n}\n\nfunc (cc *SmartContract) CreateMessage(ctx contractapi.TransactionContextInterface, instance *ContractInstance, messageID string, sendParticipantID string, receiveParticipantID string, fireflyTranID string, msgState ElementState, format string) (*Message, error) {\n\n\t// 创建消息对象\n\tinstance.InstanceMessages[messageID] = &Message{\n\t\tMessageID:            messageID,\n\t\tSendParticipantID:    sendParticipantID,\n\t\tReceiveParticipantID: receiveParticipantID,\n\t\tFireflyTranID:        fireflyTranID,\n\t\tMsgState:             msgState,\n\t\tFormat:               format,\n\t}\n\n\treturnMessage, ok := instance.InstanceMessages[messageID]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为Message\")\n\t}\n\n\treturn returnMessage, nil\n}\n\nfunc (cc *SmartContract) CreateGateway(ctx contractapi.TransactionContextInterface, instance *ContractInstance, gatewayID string, gatewayState ElementState) (*Gateway, error) {\n\n\t// 创建网关对象\n\tinstance.InstanceGateways[gatewayID] = &Gateway{\n\t\tGatewayID:    gatewayID,\n\t\tGatewayState: gatewayState,\n\t}\n\n\treturnGateway, ok := instance.InstanceGateways[gatewayID]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为Gateway\")\n\t}\n\n\treturn returnGateway, nil\n}\n\nfunc (cc *SmartContract) CreateActionEvent(ctx contractapi.TransactionContextInterface, instance *ContractInstance, eventID string, eventState ElementState) (*ActionEvent, error) {\n\t// 创建事件对象\n\tinstance.InstanceActionEvents[eventID] = &ActionEvent{\n\t\tEventID:    eventID,\n\t\tEventState: eventState,\n\t}\n\n\treturnEvent, ok := instance.InstanceActionEvents[eventID]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为ActionEvent\")\n\t}\n\n\treturn returnEvent, nil\n\n}\n\nfunc (cc *SmartContract) GetInstance(ctx contractapi.TransactionContextInterface, instanceID string) (*ContractInstance, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &instance, nil\n}\n\nfunc (cc *SmartContract) SetInstance(ctx contractapi.TransactionContextInterface, instance *ContractInstance) error {\n\tinstanceJson, err := json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = ctx.GetStub().PutState(instance.InstanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Read function\nfunc (c *SmartContract) ReadMsg(ctx contractapi.TransactionContextInterface, instanceID string, messageID string) (*Message, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tmsg, ok := instance.InstanceMessages[messageID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Message %s does not exist\", messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn msg, nil\n}\n\nfunc (c *SmartContract) ReadGtw(ctx contractapi.TransactionContextInterface, instanceID string, gatewayID string) (*Gateway, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tgtw, ok := instance.InstanceGateways[gatewayID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Gateway %s does not exist\", gatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn gtw, nil\n\n}\n\nfunc (c *SmartContract) ReadEvent(ctx contractapi.TransactionContextInterface, instanceID string, eventID string) (*ActionEvent, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tactionEvent, ok := instance.InstanceActionEvents[eventID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Event %s does not exist\", eventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn actionEvent, nil\n\n}\n\n// Change State  function\nfunc (c *SmartContract) ChangeMsgState(ctx contractapi.TransactionContextInterface, instance *ContractInstance, messageID string, msgState ElementState) error {\n\tmsg, ok := instance.InstanceMessages[messageID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Message %s does not exist\", messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\tmsg.MsgState = msgState\n\treturn nil\n}\n\nfunc (c *SmartContract) ChangeMsgFireflyTranID(ctx contractapi.TransactionContextInterface, instance *ContractInstance, fireflyTranID string, messageID string) error {\n\tmsg, ok := instance.InstanceMessages[messageID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Message %s does not exist\", messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\tmsg.FireflyTranID = fireflyTranID\n\treturn nil\n\n}\n\nfunc (c *SmartContract) ChangeGtwState(ctx contractapi.TransactionContextInterface, instance *ContractInstance, gatewayID string, gtwState ElementState) error {\n\tgtw, ok := instance.InstanceGateways[gatewayID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Gateway %s does not exist\", gatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\tgtw.GatewayState = gtwState\n\treturn nil\n}\n\nfunc (c *SmartContract) ChangeEventState(ctx contractapi.TransactionContextInterface, instance *ContractInstance, eventID string, eventState ElementState) error {\n\tactionEvent, ok := instance.InstanceActionEvents[eventID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Event %s does not exist\", eventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\tactionEvent.EventState = eventState\n\treturn nil\n\n}\n\nfunc (cc *SmartContract) ChangeBusinessRuleState(ctx contractapi.TransactionContextInterface, instance *ContractInstance, BusinessRuleID string, state ElementState) error {\n\tbusinessRule, ok := instance.InstanceBusinessRules[BusinessRuleID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"BusinessRule %s does not exist\", BusinessRuleID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\tbusinessRule.State = state\n\treturn nil\n\n}\n\n//get all message\n\nfunc (cc *SmartContract) GetAllMessages(ctx contractapi.TransactionContextInterface, instanceID string) ([]*Message, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tvar messages []*Message\n\tfor _, msg := range instance.InstanceMessages {\n\t\tmessages = append(messages, msg)\n\t}\n\n\treturn messages, nil\n}\n\nfunc (cc *SmartContract) GetAllGateways(ctx contractapi.TransactionContextInterface, instanceID string) ([]*Gateway, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tvar gateways []*Gateway\n\tfor _, gtw := range instance.InstanceGateways {\n\t\tgateways = append(gateways, gtw)\n\t}\n\n\treturn gateways, nil\n}\n\nfunc (cc *SmartContract) GetAllActionEvents(ctx contractapi.TransactionContextInterface, instanceID string) ([]*ActionEvent, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tvar actionEvents []*ActionEvent\n\tfor _, event := range instance.InstanceActionEvents {\n\t\tactionEvents = append(actionEvents, event)\n\t}\n\n\treturn actionEvents, nil\n\n}\n\nfunc (cc *SmartContract) GetAllParticipants(ctx contractapi.TransactionContextInterface, instanceID string) ([]*Participant, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tvar participants []*Participant\n\tfor _, participant := range instance.InstanceParticipants {\n\t\tparticipants = append(participants, participant)\n\t}\n\n\treturn participants, nil\n\n}\n\nfunc (cc *SmartContract) GetAllBusinessRules(ctx contractapi.TransactionContextInterface, instanceID string) ([]*BusinessRule, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tvar businessRules []*BusinessRule\n\tfor _, businessRule := range instance.InstanceBusinessRules {\n\t\tbusinessRules = append(businessRules, businessRule)\n\t}\n\n\treturn businessRules, nil\n\n}\n\nfunc (cc *SmartContract) ReadGlobalVariable(ctx contractapi.TransactionContextInterface, instanceID string) (*StateMemory, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &instance.InstanceStateMemory, nil\n\n}\n\nfunc (cc *SmartContract) SetGlobalVariable(ctx contractapi.TransactionContextInterface, instance *ContractInstance, globalVariable *StateMemory) error {\n\tinstance.InstanceStateMemory = *globalVariable\n\treturn nil\n}\n\nfunc (cc *SmartContract) ReadBusinessRule(ctx contractapi.TransactionContextInterface, instanceID string, BusinessRuleID string) (*BusinessRule, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tbusinessRule, ok := instance.InstanceBusinessRules[BusinessRuleID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"BusinessRule %s does not exist\", BusinessRuleID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn businessRule, nil\n}\n\nfunc (cc *SmartContract) ReadParticipant(ctx contractapi.TransactionContextInterface, instanceID string, participantID string) (*Participant, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tparticipant, ok := instance.InstanceParticipants[participantID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Participant %s does not exist\", participantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn participant, nil\n\n}\n\n// Don't use, since it not conform the rule of one commit one invoke\nfunc (cc *SmartContract) WriteParticipant(ctx contractapi.TransactionContextInterface, instanceID string, participantID string, participant *Participant) error {\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\tinstance.InstanceParticipants[participantID] = participant\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\nfunc (cc *SmartContract) check_msp(ctx contractapi.TransactionContextInterface, instanceID string, target_participant string) bool {\n\t// Read the target participant's msp\n\ttargetParticipant, err := cc.ReadParticipant(ctx, instanceID, target_participant)\n\tif err != nil {\n\t\treturn false\n\t}\n\tmspID, err := ctx.GetClientIdentity().GetMSPID()\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn mspID == targetParticipant.MSP\n}\n\nfunc (cc *SmartContract) check_attribute(ctx contractapi.TransactionContextInterface, instanceID string, target_participant string, attributeName string) bool {\n\ttargetParticipant, err := cc.ReadParticipant(ctx, instanceID, target_participant)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif ctx.GetClientIdentity().AssertAttributeValue(attributeName, targetParticipant.Attributes[attributeName]) != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (cc *SmartContract) check_participant(ctx contractapi.TransactionContextInterface, instanceID string, target_participant string) bool {\n\t// Read the target participant's msp\n\ttargetParticipant, err := cc.ReadParticipant(ctx, instanceID, target_participant)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif !targetParticipant.IsMulti {\n\t\t// check X509 = MSPID + @ + ID\n\t\tmspID, _ := ctx.GetClientIdentity().GetMSPID()\n\t\tpid, _ := ctx.GetClientIdentity().GetID()\n\t\tif targetParticipant.X509 == pid+\"@\"+mspID {\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// check MSP if msp!=''\n\tif targetParticipant.MSP != \"\" && !cc.check_msp(ctx, instanceID, target_participant) {\n\t\treturn false\n\t}\n\n\t// check all attributes\n\tfor key, _ := range targetParticipant.Attributes {\n\t\tif !cc.check_attribute(ctx, instanceID, target_participant, key) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (cc *SmartContract) InitLedger(ctx contractapi.TransactionContextInterface) error {\n\tstub := ctx.GetStub()\n\n\t// isInited in state\n\tisInitedBytes, err := stub.GetState(\"isInited\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to get isInited: %v\", err)\n\t}\n\tif isInitedBytes != nil {\n\t\terrorMessage := \"Chaincode has already been initialized\"\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}\n\n\tstub.PutState(\"currentInstanceID\", []byte(\"0\"))\n\n\tstub.PutState(\"isInited\", []byte(\"true\"))\n\n\tstub.SetEvent(\"initContractEvent\", []byte(\"Contract has been initialized successfully\"))\n\treturn nil\n}\n\nfunc (s *SmartContract) hashXML(ctx contractapi.TransactionContextInterface, xmlString string) (string, error) {\n\t// Calculate SHA-256 hash\n\thash := sha256.New()\n\thash.Write([]byte(xmlString))\n\thashInBytes := hash.Sum(nil)\n\thashString := hex.EncodeToString(hashInBytes)\n\tfmt.Print(hashString)\n\treturn hashString, nil\n}\n\nfunc (s *SmartContract) UpdateCID(ctx contractapi.TransactionContextInterface, instanceID string, BusinessRuleID string, cid string) error {\n\tinstanceBytes, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read from world state: %v\", err)\n\t}\n\tif instanceBytes == nil {\n\t\treturn fmt.Errorf(\"the record %s does not exist\", instanceID)\n\t}\n\n\t// Unmarshal the JSON to a Instance\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceBytes, &instance)\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal JSON: %v\", err)\n\t}\n\t// Update the Cid field\n\tinstance.InstanceBusinessRules[BusinessRuleID].CID = cid\n\n\t// Marshal the updated struct to JSON\n\tinstanceBytes, err = json.Marshal(instance)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal JSON: %v\", err)\n\t}\n\n\t// Put the updated record back into the ledger\n\terr = ctx.GetStub().PutState(instanceID, instanceBytes)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update record in world state: %v\", err)\n\t}\n\n\treturn nil\n}\n",
  "InitStartFrame": "\tcc.CreateActionEvent(ctx, &instance, \"{start_event}\", ENABLED)\n",
  "InitEndFrame": "\tcc.CreateActionEvent(ctx, &instance, \"{end_event}\", DISABLED)\n",
  "InitMessageFrame": "\tcc.CreateMessage(ctx, &instance, \"{message}\", \"{sender}\", \"{receiver}\", \"\", DISABLED, `{format}`)",
  "InitGatewayFrame": "\tcc.CreateGateway(ctx, &instance, \"{gateway}\", DISABLED)\n",
  "ChangeEventStateFrame": "    cc.ChangeEventState(ctx, instance, \"{event}\", {state})",
  "ChangeMsgStateFrame": "    cc.ChangeMsgState(ctx, instance, \"{message}\", {state})",
  "ChangeGtwStateFrame": "    cc.ChangeGtwState(ctx, instance, \"{gateway}\", {state})",
  "ChangeBusinessRuleStateFrame": "cc.ChangeBusinessRuleState(ctx, instance, \"{business_rule}\", {state})",
  "StartEventFuncFrame": "func (cc *SmartContract) {event}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tinstance, err := cc.GetInstance(ctx, instanceID)\n\n\tactionEvent, err := cc.ReadEvent(ctx, instanceID, \"{event}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif actionEvent.EventState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Event state %s is not allowed\", actionEvent.EventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeEventState(ctx, instance, \"{event}\", COMPLETED)\n\tstub.SetEvent(\"{event}\", []byte(\"Contract has been started successfully\"))\n\tcc.SetInstance(ctx, instance)\n\t{pre_activate_next_hook}\n\t{change_next_state_code}\n\t{after_all_hook}\n\tcc.SetInstance(ctx, instance)\n\treturn nil\n}}",
  "MessageSendFuncFrame": "func (cc *SmartContract) {message}_Send(ctx contractapi.TransactionContextInterface, instanceID string, fireflyTranID string {more_parameters}) error {{\n\tstub := ctx.GetStub()\n\tinstance,err := cc.GetInstance(ctx, instanceID)\n\tmsg, err := cc.ReadMsg(ctx, instanceID, \"{message}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\t//\n\tif cc.check_participant(ctx, instanceID, msg.SendParticipantID) == false{{\n\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", msg.SendParticipantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tif msg.MsgState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Message state %s is not allowed\", msg.MessageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeMsgFireflyTranID(ctx, instance, fireflyTranID, msg.MessageID)\n\t{change_self_state}\n\t{put_more_parameters}\n\tstub.SetEvent(\"{message}\", []byte(\"Message is waiting for confirmation\"))\n\tcc.SetInstance(ctx, instance)\n\t{after_all_hook}\n\tcc.SetInstance(ctx, instance)\n\treturn nil\n}}",
  "MessageCompleteFuncFrame": "func (cc *SmartContract) {message}_Complete(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tinstance,err:= cc.GetInstance(ctx, instanceID)\n\tmsg, err := cc.ReadMsg(ctx, instanceID, \"{message}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif cc.check_participant(ctx, instanceID, msg.ReceiveParticipantID) == false{{\n\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", msg.SendParticipantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tif msg.MsgState != WAITINGFORCONFIRMATION {{\n\t\terrorMessage := fmt.Sprintf(\"Event state %s is not allowed\", msg.MessageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeMsgState(ctx, instance, msg.MessageID, COMPLETED)\n\tstub.SetEvent(\"{message}\", []byte(\"Message has been done\"))\n\tcc.SetInstance(ctx, instance)\n\n\t{pre_activate_next_hook}\n\t{change_next_state_code}\n\n\t{after_all_hook}\n\tcc.SetInstance(ctx, instance)\n\treturn nil\n}}",
  "ParallelGatewaySplitFuncFrame": "func (cc *SmartContract) {parallel_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tinstance, err := cc.GetInstance(ctx, instanceID)\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{parallel_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instance, gtw.GatewayID, ENABLED)\n\tstub.SetEvent(\"{parallel_gateway}\", []byte(\"Gateway has been done\"))\n\tcc.SetInstance(ctx, instance)\n\t{pre_activate_next_hook}\n\n\t{change_next_state_code}\n\tcc.SetInstance(ctx, instance)\n\n\treturn nil\n}}",
  "ParallelGatewayMergeFuncFrame": "func (cc *SmartContract) {parallel_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tinstance,err := cc.GetInstance(ctx, instanceID)\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{parallel_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instance, gtw.GatewayID, COMPLETED)\n\tstub.SetEvent(\"{parallel_gateway}\", []byte(\"Gateway has been done\"))\n\n\t{pre_activate_next_hook}\n\t{change_next_state_code}\n\t{after_all_hook}\n\tcc.SetInstance(ctx, instance)\n\treturn nil\n}}",
  "EventBasedGatewayFuncFrame": "func (cc *SmartContract) {event_based_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{ \n\tstub := ctx.GetStub()\n\tinstance,err:=cc.GetInstance(ctx, instanceID)\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{event_based_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instance, gtw.GatewayID, COMPLETED)\n\tstub.SetEvent(\"{event_based_gateway}\", []byte(\"EventbasedGateway has been done\"))\n\tcc.SetInstance(ctx, instance)\n \t{pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\tcc.SetInstance(ctx, instance)\n    return nil\n}}",
  "ExclusiveGatewaySplitFuncFrame": "func (cc *SmartContract) {exclusive_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tinstance,err:=cc.GetInstance(ctx, instanceID)\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{exclusive_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instance, gtw.GatewayID, COMPLETED)\n\tstub.SetEvent(\"{exclusive_gateway}\", []byte(\"ExclusiveGateway has been done\"))\n\tcc.SetInstance(ctx, instance)\n    {pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\tcc.SetInstance(ctx, instance)\n\treturn nil\n}}",
  "ExclusiveGatewayMergeFuncFrame": "func (cc *SmartContract) {exclusive_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tinstance,err:=cc.GetInstance(ctx, instanceID)\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{exclusive_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instance, gtw.GatewayID, COMPLETED)\n\tstub.SetEvent(\"{exclusive_gateway}\", []byte(\"ExclusiveGateway has been done\"))\n\tcc.SetInstance(ctx, instance)\n    {pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\tcc.SetInstance(ctx, instance)\n\treturn nil\n}}",
  "CheckMessageStateFrame": "func() bool {{ msg, err := cc.ReadMsg(ctx, instanceID, \"{message}\"); return err == nil && msg.MsgState == {state} }}()",
  "CheckGtwStateFrame": "func() bool {{ gtw, err := cc.ReadGtw(ctx, instanceID, \"{gateway}\"); return err == nil && gtw.GatewayState == {state} }}()",
  "CheckEventStateFrame": "func() bool {{ event, err := cc.ReadEvent(ctx, \"{event}\"); return err == nil && event.EventState == {state} }}()",
  "ConditionToDoFrame": "if {condition} {{\n\t{todo}\n}}",
  "StateMemoryDefinitionFrame": "type StateMemory struct {{\n    {fields}\n}}",
  "StateReadAndSetFunc": "func (cc *SmartContract) ReadState(ctx contractapi.TransactionContextInterface, instanceID string) (*StateMemory, error) {\n\tstateJSON, err := ctx.GetStub().GetState(\"currentMemory\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif stateJSON == nil {\n\t\t// return a empty stateMemory\n\t\treturn &StateMemory{}, nil\n\t}\n\n\tvar stateMemory StateMemory\n\terr = json.Unmarshal(stateJSON, &stateMemory)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &stateMemory, nil\n}\n\nfunc (cc *SmartContract) PutState(ctx contractapi.TransactionContextInterface, stateName string, stateValue interface{}) error {\n\tstub := ctx.GetStub()\n\tcurrentMemory, err := cc.ReadState(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tval := reflect.ValueOf(currentMemory)\n\tif val.Kind() != reflect.Ptr || val.Elem().Kind() != reflect.Struct {\n\t\treturn errors.New(\"currentMemory is not a struct pointer\")\n\t}\n\tfield := val.Elem().FieldByName(stateName)\n\tif !field.IsValid() {\n\t\treturn errors.New(\"field does not exist\")\n\t}\n\tif !field.CanSet() {\n\t\treturn errors.New(\"field cannot be set\")\n\t}\n\t// 根据字段类型将stateValue转换为合适的类型\n\tswitch field.Interface().(type) {\n\tcase string:\n\t\tstringValue, ok := stateValue.(string)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a string\")\n\t\t}\n\t\tfield.SetString(stringValue)\n\tcase int:\n\t\tintValue, ok := stateValue.(int)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not an int\")\n\t\t}\n\t\tfield.SetInt(int64(intValue))\n\tcase float64:\n\t\tfloatValue, ok := stateValue.(float64)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a float64\")\n\t\t}\n\t\tfield.SetFloat(floatValue)\n\tcase bool:\n\t\tboolValue, ok := stateValue.(bool)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a bool\")\n\t\t}\n\t\tfield.SetBool(boolValue)\n\t// 添加其他类型的处理...\n\tdefault:\n\t\treturn errors.New(\"unsupported field type\")\n\t}\n\n\tcurrentMemoryJSON, err := json.Marshal(currentMemory)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(\"currentMemory\", currentMemoryJSON)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n}",
  "PutStateFuncFrame": "    cc.PutState(ctx, instanceID, \"{name}\", {value})",
  "ReadStateFuncFrame": "    {stateName}:=currentMemory.{stateName}\n",
  "ReadCurrentMemoryCode": "    currentMemory,err := cc.ReadState(ctx)\n    if err != nil {\n        return err\n    }\n",
  "ReadAndSetGloablVariable": "func (cc *SmartContract) ReadGlobalVariable(ctx contractapi.TransactionContextInterface, instanceID string) (*StateMemory, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\treturn nil, fmt.Errorf(\"The instance %s does not exist\", instanceID)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstateMemory, ok := instance.StateMemory.(*StateMemory)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"The instance %s has no valid StateMemory\", instanceID)\n\t}\n\n\treturn stateMemory, nil\n}\n\nfunc (cc *SmartContract) SetGlobalVariable(ctx contractapi.TransactionContextInterface, instance *ContractInstance, globalVariable *StateMemory) error {\n\tinstance.StateMemory = globalVariable\n\treturn instance\n\n}",
  "SetGlobalVariableFuncFrame": "\tglobalMemory,readGloabolError := cc.ReadGlobalVariable(ctx, instanceID)\n\tif readGloabolError != nil {{\n\t\tfmt.Println(readGloabolError.Error())\n\t\treturn readGloabolError\n\t}}\n\t{items}\n\tsetGloabolErrror :=cc.SetGlobalVariable(ctx, instance, globalMemory)\n\tif setGloabolErrror != nil {{\n\t\tfmt.Println(setGloabolErrror.Error())\n\t\treturn setGloabolErrror\n\t}}",
  "SetGlobalVaribaleFuncItemFrame": "\tglobalMemory.{name} = {value}",
  "ReadGlobalVariable": "\tcurrentMemory, err := cc.ReadGlobalVariable(ctx, instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n",
  "InitParticipantFrame": "\tcc.CreateParticipant(ctx, &instance, \"{participant_id}\", initParameters.{participant_id}.MSP, initParameters.{participant_id}.Attributes, initParameters.{participant_id}.X509,initParameters.{participant_id}.IsMulti, {multi_maximum}, {multi_minimum})",
  "CreateInstanceFuncFrame": "func (cc *SmartContract) CreateInstance(ctx contractapi.TransactionContextInterface, initParametersBytes string) (string, error) {{\n\tstub := ctx.GetStub()\n\n\tisInitedBytes, err := stub.GetState(\"isInited\")\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to read from world state. %s\", err.Error())\n\t}}\n\n\tif isInitedBytes == nil {{\n\t\treturn \"\", fmt.Errorf(\"The instance has not been initialized.\")\n\t}}\n\n\tisInited, err := strconv.ParseBool(string(isInitedBytes))\n\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"fail To Resolve isInited\")\n\t}}\n\tif !isInited {{\n\t\treturn \"\", fmt.Errorf(\"The instance has not been initialized.\")\n\t}}\n\n\t// get the instanceID\n\tinstanceIDBytes, err := stub.GetState(\"currentInstanceID\")\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to read from world state. %s\", err.Error())\n\t}}\n\n\tinstanceID := string(instanceIDBytes)\n\t\n\n\t// Create the instance with the data from the InitParameters\n\tvar initParameters InitParameters\n\terr = json.Unmarshal([]byte(initParametersBytes), &initParameters)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to unmarshal. %s\", err.Error())\n\t}}\n\n\tinstance := ContractInstance{{\n\t\tInstanceID:          instanceID,\n\t\tInstanceStateMemory: StateMemory{{}},\n\t\tInstanceMessages:    make(map[string]*Message),\n\t\tInstanceActionEvents: make(map[string]*ActionEvent),\n\t\tInstanceGateways: make(map[string]*Gateway),\n\t\tInstanceParticipants : make(map[string]*Participant),\n\t\tInstanceBusinessRules: make(map[string]*BusinessRule),\n\t}}\n\n\t// Update the currentInstanceID\n\n\t{create_elements_code}\n\n\t// Save the instance\n\tinstanceBytes, err := json.Marshal(instance)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to marshal. %s\", err.Error())\n\t}}\n\n\terr = stub.PutState(instanceID, instanceBytes)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to put state. %s\", err.Error())\n\t}}\n\n\n\teventPayload := map[string]string{{\n\t\t\"InstanceID\": instanceID, \n\t\t{event_content}\n\t}}\n\n\teventPayloadAsBytes, err := json.Marshal(eventPayload)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to marshal event payload: %v\", err)\n\t}}\n\n\terr = ctx.GetStub().SetEvent(\"InstanceCreated\", eventPayloadAsBytes)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to set event: %v\", err)\n\t}}\n\n\n\n\tinstanceIDInt, err := strconv.Atoi(instanceID)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to convert instanceID to int. %s\", err.Error())\n\t}}\n\n\tinstanceIDInt++\n\tinstanceID = strconv.Itoa(instanceIDInt)\n\n\tinstanceIDBytes = []byte(instanceID)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to marshal instanceID. %s\", err.Error())\n\t}}\n\n\terr = stub.PutState(\"currentInstanceID\", instanceIDBytes)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to put state. %s\", err.Error())\n\t}}\n\n\treturn instanceID, nil\n\n}}",
  "InitParametersTypeDefFrame": "type InitParameters struct {{\n    {fields}\n}}",
  "InvokeChaincodeFunc": "func (cc *SmartContract) Invoke_Other_chaincode(ctx contractapi.TransactionContextInterface, chaincodeName string, channel string, _args [][]byte) (string, error) {\n\tstub := ctx.GetStub()\n\tresponse := stub.InvokeChaincode(chaincodeName, _args, channel)\n\n\tif response.Status != shim.OK {\n\t\treturn \"\", fmt.Errorf(\"failed to invoke chaincode. Response status: %d. Response message: %s\", response.Status, response.Message)\n\t}\n\n\tfmt.Print(\"response.Payload: \")\n\tfmt.Println(string(response.Payload))\n\n\treturn string(response.Payload), nil\n}",
  "RegisterFunc": "func (cc *SmartContract) RegisterParticipant(ctx contractapi.TransactionContextInterface, instanceID string, targetParticipantID string) error {\n\t{\n\t\t// check if the participant is single\n\t\tvar targetParticipant Participant\n\t\tparticipant, _ := cc.ReadParticipant(ctx, instanceID, targetParticipantID)\n\t\tif participant.IsMulti {\n\t\t\t{\n\t\t\t\treturn fmt.Errorf(\"The participant is not multi\")\n\t\t\t}\n\t\t}\n\n\t\t// check ACL\n\n\t\tif !cc.check_participant(ctx, instanceID, targetParticipantID) {\n\t\t\treturn fmt.Errorf(\"The participant is not allowed to be registered\")\n\t\t}\n\n\t\t// Read the identity of invoker ,and binding it's identity to the participant\n\n\t\t// Get the identity of the invoker\n\t\tinvokerIdentity, err := ctx.GetClientIdentity().GetID()\n\t\tmspIndentity, err := ctx.GetClientIdentity().GetMSPID()\n\n\t\tX509 := invokerIdentity + \"@\" + mspIndentity\n\n\t\t// save the identity to the participant\n\t\ttargetParticipant.X509 = X509\n\n\t\t// save the participant\n\t\terr = cc.WriteParticipant(ctx, instanceID, targetParticipantID, &targetParticipant)\n\t\tif err != nil {\n\t\t\t{\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}",
  "CheckRegisterFunc": "func (cc *SmartContract) CheckRegister(ctx contractapi.TransactionContextInterface, instanceID string) (bool, error) {\n\tstub := ctx.GetStub()\n\n\t// Check if the instance has been registered\n\tinstanceBytes, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"Failed to read from world state. %s\", err.Error())\n\t}\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceBytes, &instance)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"Failed to unmarshal. %s\", err.Error())\n\t}\n\n\tif instance.InstanceState == READY {\n\t\treturn true, nil\n\t}\n\n\t// set State depend on Participant with IsMulti=true\n\n\tfor element, value := range instance.InstanceElements {\n\t\tparticipant, ok := value.(*Participant)\n\t\tif ok {\n\t\t\tif !participant.IsMulti && participant.X509 == \"\" {\n\t\t\t\treturn false, fmt.Errorf(\"The participant %s is not registered.\", element)\n\t\t\t}\n\t\t}\n\t}\n\n\t// set State depend on Participant with IsMulti=false\n\tinstance.InstanceState = READY\n\tinstanceBytes, err = json.Marshal(instance)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"Failed to marshal. %s\", err.Error())\n\t}\n\n\terr = stub.PutState(instanceID, instanceBytes)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"Failed to put state. %s\", err.Error())\n\t}\n\n\treturn true, nil\n}",
  "InitBusinessRuleFrame": "\tcc.CreateBusinessRule(ctx, &instance, \"{business_rule}\", initParameters.{business_rule}_Content, initParameters.{business_rule}_DecisionID, initParameters.{business_rule}_ParamMapping)",
  "BusinessRuleFuncFrame": "func (cc *SmartContract) {business_rule}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\n\n\tinstance, err := cc.GetInstance(ctx, instanceID)\n\t// Read Business Info\n\tbusinessRule, err := cc.ReadBusinessRule(ctx, instanceID, \"{business_rule}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\t// Check the BusinessRule State\n\tif businessRule.State != ENABLED {{\n\t\treturn fmt.Errorf(\"The BusinessRule is not ENABLED\")\n\t}}\n\n\teventPayload := map[string]string{{\n\t\t\"ID\":        \"{business_rule}\",\n\t\t\"InstanceID\": instanceID,\n\t\t\"Func\":\t   \"{business_rule}_Continue\",\n\t\t\"CID\": businessRule.CID, \n\t}}\n\n\teventPayloadAsBytes, err := json.Marshal(eventPayload)\n\tif err != nil {{\n\t\treturn fmt.Errorf(\"failed to marshal event payload: %v\", err)\n\t}}\n\n\terr = ctx.GetStub().SetEvent(\"DMNContentRequired\", eventPayloadAsBytes)\n\tif err != nil {{\n\t\treturn fmt.Errorf(\"failed to set event: %v\", err)\n\t}}\n\n\tcc.ChangeBusinessRuleState(ctx, instance, \"{business_rule}\", WAITINGFORCONFIRMATION)\n\tcc.SetInstance(ctx, instance)\n\n\treturn nil\n}}",
  "BusinessRuleContinueFuncFrame": "func (cc *SmartContract) {business_rule}_Continue(ctx contractapi.TransactionContextInterface, instanceID string, ContentOfDmn string) error {{\n\t// Read Business Info\n\tinstance,err:=cc.GetInstance(ctx, instanceID)\n\tbusinessRule, err := cc.ReadBusinessRule(ctx, instanceID, \"{business_rule}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\t// Check the BusinessRule State\n\tif businessRule.State != WAITINGFORCONFIRMATION {{\n\t\treturn fmt.Errorf(\"The BusinessRule is not Actived\")\n\t}}\n\n\t// check the hash\n\thashString, _ := cc.hashXML(ctx, ContentOfDmn)\n\tif hashString != businessRule.Hash {{\n\t\treturn fmt.Errorf(\"The hash is not matched\")\n\t}}\n\n\t// Combine the Parameters\n\t_args := make([][]byte, 4)\n\t_args[0] = []byte(\"createRecord\")\n\t// input in json format\n\tParamMapping := businessRule.ParamMapping\n\trealParamMapping := make(map[string]interface{{}})\n\tglobalVariable, _err := cc.ReadGlobalVariable(ctx, instanceID)\n\tif _err != nil {{\n\t\treturn _err\n\t}}\n\n\tfor key, value := range ParamMapping {{\n\t\tfield := reflect.ValueOf(globalVariable).Elem().FieldByName(strings.Title(value))\n\t\tif !field.IsValid() {{\n\t\t\treturn fmt.Errorf(\"The field %s is not valid\", value)\n\t\t}}\n\t\trealParamMapping[key] = field.Interface()\t\t\n\t}}\n\tvar inputJsonBytes []byte\n\tinputJsonBytes, err= json.Marshal(realParamMapping)\n\tif err != nil {{\n\t\treturn err\n\t}}\n\t_args[1] = inputJsonBytes\n\n\t// DMN Content\n\t_args[2] = []byte(ContentOfDmn)\n\n\t// decisionId\n\t_args[3] = []byte(businessRule.DecisionID)\n\n\t// Invoke DMN Engine Chaincode\n\tvar resJson string\n\tresJson, err=cc.Invoke_Other_chaincode(ctx, \"asset:v1\",\"default\", _args)\n\n\t// Set the Result\n\tvar res map[string]interface{{}}\n\terr = json.Unmarshal([]byte(resJson), &res)\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\toutput := res[\"output\"]\n\tfmt.Println(\"output: \", output)  \n\tif outputArr, ok := output.([]interface{{}}); ok {{  \n\t\tfor _, item := range outputArr {{  \n\t\t\titemMap := item.(map[string]interface{{}})  \n\t\t\tfor key, value := range itemMap {{  \n\t\t\t\tfmt.Printf(\"Key: %s, Type: %T, Value: %v\\n\", key,value,value)  \n\t\t\t\tglobalName , _ := ParamMapping[key]\n\t\t\t\tfield := reflect.ValueOf(globalVariable).Elem().FieldByName(strings.Title(globalName))\n\t\t\t\tif !field.IsValid() {{\n\t\t\t\t\treturn fmt.Errorf(\"The field %s is not valid\", key)\n\t\t\t\t}}\n\t\t\t\tswitch field.Kind() {{\n\t\t\t\t\tcase reflect.Int:\n\t\t\t\t\t\tif valueFloat, ok := value.(float64); ok {{\n\t\t\t\t\t\t\tfield.SetInt(int64(valueFloat))\n\t\t\t\t\t\t}} else {{\n\t\t\t\t\t\t\treturn fmt.Errorf(\"Unable to convert %v to int\", value)\n\t\t\t\t\t\t}}\n\t\t\t\t\tcase reflect.String:\n\t\t\t\t\t\tif valueStr, ok := value.(string); ok {{\n\t\t\t\t\t\t\tfield.SetString(valueStr)\n\t\t\t\t\t\t}} else {{\n\t\t\t\t\t\t\treturn fmt.Errorf(\"Unable to convert %v to string\", value)\n\t\t\t\t\t\t}}\n\t\t\t\t\tcase reflect.Bool: // 处理布尔类型\n\t\t\t\t\t\tif valueBool, ok := value.(bool); ok {{\n\t\t\t\t\t\t\tfield.SetBool(valueBool)\n\t\t\t\t\t\t}} else {{\n\t\t\t\t\t\t\treturn fmt.Errorf(\"Unable to convert %v to bool\", value)\n\t\t\t\t\t\t}}\n\t\t\t\t\t// 其他类型转换可以根据需求添加\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn fmt.Errorf(\"Unsupported field type: %s\", field.Type())\n                }}\n\t\t\t\t// field.Set(reflect.ValueOf(value))\n\t\t\t}}  \n\t\t}}  \n\t}}  \n\n\t// Update the GlobalVariable\n\terr = cc.SetGlobalVariable(ctx, instance, globalVariable)\n\n\t// Change the BusinessRule State\n\tcc.ChangeBusinessRuleState(ctx, instance, \"{business_rule}\", COMPLETED)\n\n    {pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\n\tcc.SetInstance(ctx, instance)\n\teventPayload := map[string]string{{\n\t\t\"ID\":         \"Activity_0ibsbry_Continue\",\n\t\t\"InstanceID\": instanceID,\n\t}}\n\n\teventPayloadAsBytes, err := json.Marshal(eventPayload)\n\tif err != nil {{\n\t\treturn fmt.Errorf(\"failed to marshal event payload: %v\", err)\n\t}}\n\n\terr = ctx.GetStub().SetEvent(\"Avtivity_continueDone\", eventPayloadAsBytes)\n\tif err != nil {{\n\t\treturn fmt.Errorf(\"failed to set event: %v\", err)\n\t}}\n\treturn nil\n\n}}"
}